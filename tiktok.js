const pool = require('./database');
const axios = require('axios');
const { Markup } = require('telegraf');

// Server configurations
const SERVERS = {
    '1': { name: 'M√°y ch·ªß 1 - Nhanh', cost: 250, id: 'server_1' },
    '2': { name: 'M√°y ch·ªß 2 - Ch·∫≠m', cost: 150, id: 'server_6' }
};

// State management for user sessions
const userStates = new Map();

function initUserState(userId) {
    return {
        step: 'SERVER_SELECTION',
        serverId: null,
        link: null,
        quantity: null,
        totalCost: null,
        startTime: Date.now()
    };
}

function isValidTikTokLink(link) {
    try {
        const url = new URL(link);
        return url.hostname.includes('tiktok.com') ||
            url.hostname.includes('vm.tiktok.com') ||
            url.hostname.includes('vt.tiktok.com');
    } catch {
        return false;
    }
}

async function checkUserBalance(userId) {
    try {
        const result = await pool.query('SELECT balance FROM users WHERE user_id = $1', [userId]);
        return result.rows[0]?.balance || 0;
    } catch (error) {
        console.error('Error checking balance:', error);
        throw error;
    }
}

async function deductBalance(userId, amount) {
    const client = await pool.connect();
    try {
        await client.query('BEGIN');
        const result = await client.query(
            'UPDATE users SET balance = balance - $1 WHERE user_id = $2 AND balance >= $1 RETURNING balance',
            [amount, userId]
        );
        if (result.rows.length === 0) {
            throw new Error('Insufficient balance');
        }
        await client.query('COMMIT');
        return result.rows[0].balance;
    } catch (error) {
        await client.query('ROLLBACK');
        throw error;
    } finally {
        client.release();
    }
}

async function placeOrderViaApi(orderData) {
    const apiUrl = 'https://hacklike17.com/api/tiktok/follow_tiktok';

    console.log('Sending API request:', {
        server: SERVERS[orderData.serverId].id,
        link: orderData.link,
        count: orderData.quantity
    });

    const formData = new URLSearchParams();
    formData.append('token', process.env.API_TOKEN);
    formData.append('link', orderData.link);
    formData.append('server', SERVERS[orderData.serverId].id);
    formData.append('count', orderData.quantity.toString());
    formData.append('note', 'test');

    try {
        const response = await axios.post(apiUrl, formData, {
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        });

        console.log('API Response:', response.data);

        if (response.data.status === 1) {
            return {
                orderId: response.data.order_id,
                original: response.data.original
            };
        }
        throw new Error(response.data.msg || 'API Error');
    } catch (error) {
        console.error('API Error:', error.response?.data || error.message);
        throw error;
    }
}

async function saveOrder(orderData) {
    const query = `
        INSERT INTO orders (
            user_id, api_order_id, service_type, link,
            quantity, server, total_cost, provider,
            api_endpoint, status, created_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW())
            RETURNING order_id`;

    const values = [
        orderData.userId,
        orderData.apiOrderId,
        'TƒÉng Follow',
        orderData.link,
        orderData.quantity,
        SERVERS[orderData.serverId].name,
        orderData.totalCost,
        'Hacklike17',
        'https://hacklike17.com/api/tiktok/follow_tiktok',
        'Processing'
    ];

    try {
        const result = await pool.query(query, values);
        return result.rows[0].order_id;
    } catch (error) {
        console.error('Error saving order:', error);
        throw error;
    }
}

module.exports = {
    userStates,
    handleTiktokFollowers: async (ctx) => {
        const userId = ctx.from.id;
        userStates.set(userId, initUserState(userId));

        await ctx.reply('üõ† Ch·ªçn m√°y ch·ªß:', Markup.inlineKeyboard([
            [Markup.button.callback('M√°y ch·ªß 1 - Nhanh', 'server_1')],
            [Markup.button.callback('M√°y ch·ªß 2 - Ch·∫≠m', 'server_2')]
        ]));
    },

    handleServerSelection: async (ctx) => {
        try {
            const userId = ctx.from.id;
            const serverId = ctx.match[1];
            const state = userStates.get(userId) || initUserState(userId);

            if (!SERVERS[serverId]) {
                await ctx.reply('‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá.');
                return;
            }

            state.serverId = serverId;
            state.step = 'LINK_INPUT';
            userStates.set(userId, state);

            await ctx.answerCbQuery();
            await ctx.reply('üîó Vui l√≤ng nh·∫≠p link TikTok:');
        } catch (error) {
            console.error('Server selection error:', error);
            await ctx.reply('‚ùå ƒê√£ x·∫£y ra l·ªói. Vui l√≤ng th·ª≠ l·∫°i.');
        }
    },

    handleOrderMessage: async (ctx) => {
        try {
            const userId = ctx.from.id;
            const state = userStates.get(userId);
    
            if (!state) {
                await ctx.reply('‚ùå Vui l√≤ng b·∫Øt ƒë·∫ßu l·∫°i t·ª´ ƒë·∫ßu b·∫±ng c√°ch ch·ªçn "üõí Order Now"');
                return;
            }
    
            // Check session timeout (5 minutes)
            if (Date.now() - state.startTime > 5 * 60 * 1000) {
                userStates.delete(userId);
                await ctx.reply('‚ùå Phi√™n l√†m vi·ªác ƒë√£ h·∫øt h·∫°n. Vui l√≤ng b·∫Øt ƒë·∫ßu l·∫°i.');
                return;
            }
    
            switch (state.step) {
                case 'LINK_INPUT':
                    if (!isValidTikTokLink(ctx.message.text)) {
                        await ctx.reply('‚ùå Link kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p l·∫°i link TikTok.');
                        return;
                    }
                    state.link = ctx.message.text;
                    state.step = 'QUANTITY_INPUT';
                    await ctx.reply('üî¢ Nh·∫≠p s·ªë l∆∞·ª£ng follow mu·ªën tƒÉng:');
                    break;
    
                case 'QUANTITY_INPUT':
                    const quantity = parseInt(ctx.message.text);
                    if (isNaN(quantity) || quantity < 100 || quantity > 10000) {
                        await ctx.reply('‚ùå S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p s·ªë t·ª´ 100 ƒë·∫øn 10,000.');
                        return;
                    }
    
                    state.quantity = quantity;
                    state.totalCost = quantity * SERVERS[state.serverId].cost;
                    state.step = 'CONFIRMATION';
    
                    const userBalance = await checkUserBalance(userId);
                    if (userBalance < state.totalCost) {
                        await ctx.reply(
                            `‚ùå S·ªë d∆∞ kh√¥ng ƒë·ªß!\n\n` +
                            `üí∞ S·ªë d∆∞ hi·ªán t·∫°i: ${userBalance.toLocaleString()}ƒë\n` +
                            `üí∞ S·ªë ti·ªÅn c·∫ßn: ${state.totalCost.toLocaleString()}ƒë\n` +
                            `üí∞ C·∫ßn n·∫°p th√™m: ${(state.totalCost - userBalance).toLocaleString()}ƒë`
                        );
                        userStates.delete(userId);
                        return;
                    }
    
                    const orderKey = `order_${userId}_${Date.now()}`;
                    const orderData = {
                        userId,
                        serverId: state.serverId,
                        link: state.link,
                        quantity: state.quantity,
                        totalCost: state.totalCost
                    };
    
                    // L∆∞u orderData v√†o temporary storage
                    userStates.set(orderKey, orderData);
    
                    await ctx.reply(
                        `üìã CHI TI·∫æT ƒê∆†N H√ÄNG\n\n` +
                        `üîó Link TikTok:\n${state.link}\n\n` +
                        `üìä TH√îNG TIN:\n` +
                        `‚îú S·ªë l∆∞·ª£ng: ${state.quantity.toLocaleString()} follow\n` +
                        `‚îú M√°y ch·ªß: ${SERVERS[state.serverId].name}\n` +
                        `‚îú ƒê∆°n gi√°: ${SERVERS[state.serverId].cost.toLocaleString()}ƒë\n` +
                        `‚îî T·ªïng ti·ªÅn: ${state.totalCost.toLocaleString()}ƒë\n\n` +
                        `üí∞ S·ªë d∆∞ hi·ªán t·∫°i: ${userBalance.toLocaleString()}ƒë\n` +
                        `üí∞ S·ªë d∆∞ c√≤n l·∫°i: ${(userBalance - state.totalCost).toLocaleString()}ƒë\n\n` +
                        `‚ö†Ô∏è L∆ØU √ù:\n` +
                        `‚Ä¢ Vui l√≤ng ki·ªÉm tra k·ªπ link tr∆∞·ªõc khi x√°c nh·∫≠n\n` +
                        `‚Ä¢ ƒê∆°n ƒë√£ t·∫°o kh√¥ng th·ªÉ h·ªßy ho·∫∑c ho√†n ti·ªÅn\n` +
                        `‚Ä¢ Th·ªùi gian ho√†n th√†nh t·ª´ 1-24h t√πy s·ªë l∆∞·ª£ng`,
                        Markup.inlineKeyboard([
                            [
                                Markup.button.callback('‚úÖ X√°c nh·∫≠n', `confirm_${orderKey}`),
                                Markup.button.callback('‚ùå Hu·ª∑', `cancel_${orderKey}`)
                            ]
                        ])
                    );
                    break;
            }
        } catch (error) {
            console.error('Message handling error:', error);
            await ctx.reply('‚ùå ƒê√£ x·∫£y ra l·ªói. Vui l√≤ng th·ª≠ l·∫°i.');
            userStates.delete(ctx.from.id);
        }
    },

    handleOrderButtons: async (ctx) => {
        try {
            const action = ctx.match[0];
            const orderKey = action.replace(/^(confirm|cancel)_/, '');
            const orderData = userStates.get(orderKey);

            if (!orderData) {
                await ctx.answerCbQuery('ƒê∆°n h√†ng ƒë√£ h·∫øt h·∫°n ho·∫∑c kh√¥ng t·ªìn t·∫°i');
                await ctx.editMessageText('‚ùå ƒê∆°n h√†ng ƒë√£ h·∫øt h·∫°n ho·∫∑c kh√¥ng t·ªìn t·∫°i.');
                return;
            }

            if (action.startsWith('confirm_')) {
                await ctx.answerCbQuery('ƒêang x·ª≠ l√Ω ƒë∆°n h√†ng...');

                // 1. Tr·ª´ ti·ªÅn
                await deductBalance(orderData.userId, orderData.totalCost);

                // 2. ƒê·∫∑t ƒë∆°n qua API
                const apiResponse = await placeOrderViaApi(orderData);

                // 3. L∆∞u ƒë∆°n h√†ng
                const orderId = await saveOrder({
                    ...orderData,
                    apiOrderId: apiResponse.orderId
                });

                // 4. C·∫≠p nh·∫≠t message th√†nh c√¥ng
                await ctx.editMessageText(
                    `‚úÖ ƒê·∫∂T ƒê∆†N TH√ÄNH C√îNG!\n\n` +
                    `üìã TH√îNG TIN ƒê∆†N H√ÄNG:\n` +
                    `üÜî M√£ ƒë∆°n: #${apiResponse.orderId}\n` +
                    `üîó Link: ${orderData.link}\n` +
                    `üë• S·ªë l∆∞·ª£ng: ${orderData.quantity.toLocaleString()} follow\n` +
                    `üí∞ T·ªïng ti·ªÅn: ${orderData.totalCost.toLocaleString()}ƒë\n` +
                    `‚è≥ Tr·∫°ng th√°i: ƒêang x·ª≠ l√Ω\n\n` +
                    `‚ÑπÔ∏è ƒê∆°n h√†ng s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω trong v√≤ng 24h.\n` +
                    `üìû Li√™n h·ªá admin n·∫øu c·∫ßn h·ªó tr·ª£ th√™m.`
                );

                // Xo√° tr·∫°ng th√°i phi√™n sau khi x√°c nh·∫≠n th√†nh c√¥ng
                userStates.delete(orderKey);
                userStates.delete(orderData.userId);

            } else if (action.startsWith('cancel_')) {
                await ctx.answerCbQuery('ƒê√£ hu·ª∑ ƒë∆°n h√†ng');
                await ctx.editMessageText('‚ùå ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c hu·ª∑.');

                // Xo√° tr·∫°ng th√°i phi√™n khi h·ªßy ƒë∆°n
                userStates.delete(orderKey);
                userStates.delete(orderData.userId);
            }
        } catch (error) {
            console.error('Button handling error:', error);
            await ctx.answerCbQuery('C√≥ l·ªói x·∫£y ra');
            await ctx.reply('‚ùå C√≥ l·ªói x·∫£y ra khi x·ª≠ l√Ω ƒë∆°n h√†ng. Vui l√≤ng th·ª≠ l·∫°i sau.');
        }
    }
};